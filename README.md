# Data Structures and Algorithms - Coursework Portfolio

## Overview
This repository contains comprehensive implementations of fundamental data structures and algorithms as part of my academic coursework in Computer Science. Each module demonstrates practical application of theoretical concepts with complete, working solutions in C++.

## üéØ Course Objectives
- Master fundamental data structures and their implementations
- Understand algorithm design and analysis
- Develop efficient problem-solving skills
- Implement complex algorithms from scratch
- Analyze time and space complexity

## üìö Course Modules

### 1. Arrays & Linked Lists
**Files:** `1.Array&LinkedList/Solve/`
- **Custom List Implementation:** Template-based generic list with dynamic resizing
- **LRU Cache:** Least Recently Used cache implementation using doubly-linked list
- **Key Features:**
  - O(1) insertion and deletion operations
  - Dynamic memory management
  - Iterator pattern implementation
  - File I/O for data persistence

### 2. Stacks & Queues
**Files:** `2.Stack&Queue/Solve/`
- **Array-based Queue:** Circular queue implementation with overflow handling
- **List-based Stack:** Dynamic stack using linked list structure
- **Advanced Features:**
  - Automatic capacity doubling
  - Circular buffer optimization
  - Memory-efficient operations
  - Real-time data processing capabilities

### 3. Binary Search Trees
**Files:** `3.BinarySearchTree/Solve/`
- **BST Implementation:** Complete binary search tree with all standard operations
- **Key Operations:**
  - Insertion: O(log n) average case
  - Search: O(log n) average case
  - Deletion with rebalancing
  - In-order, pre-order, post-order traversals
  - Parent pointer maintenance

### 4. Heap Data Structure
**Files:** `4.Heap/Solve.cpp`
- **Min Heap Implementation:** Complete heap with priority queue functionality
- **Core Operations:**
  - Insert: O(log n)
  - Extract Min: O(log n)
  - Heapify: O(n)
  - Dynamic capacity management
  - Priority-based sorting

### 5. Graph Algorithms
**Files:** `5.Graph/Solve.cpp`
- **Graph Implementation:** Adjacency list representation
- **Algorithm Implementations:**
  - Breadth-First Search (BFS)
  - Depth-First Search (DFS)
  - Graph traversal and pathfinding
  - Connected components detection
  - Custom Vector class for adjacency lists

### 6. Greedy Algorithms
**Files:** `6.GreedyAlgorithm/Solve/`
- **Scheduling Algorithm:** Customer service optimization using min-heap
- **Key Features:**
  - Priority queue implementation
  - Greedy scheduling strategy
  - Time complexity optimization
  - Real-world problem modeling

### 7. Divide and Conquer
**Files:** `7.DivideAndConquer/Solve.cpp`
- **Algorithm Implementation:** Classic divide-and-conquer problems
- **Problem Types:**
  - Merge sort implementation
  - Recursive problem solving
  - Subproblem decomposition
  - Optimal substructure analysis

### 8. Dynamic Programming
**Files:** `8.DynamicProgramming/Solve.cpp`
- **Knapsack Problem:** 0/1 knapsack with optimal solution
- **Implementation Features:**
  - Bottom-up DP approach
  - Memory optimization
  - Solution reconstruction
  - File-based input/output

## üõ† Technical Skills Demonstrated

### Programming Languages
- **C++:** Advanced template programming, memory management, STL concepts
- **Object-Oriented Design:** Classes, inheritance, polymorphism, encapsulation

### Data Structures
- Arrays, Linked Lists, Stacks, Queues
- Trees (Binary Search Trees)
- Heaps (Min/Max Heaps)
- Graphs (Adjacency Lists)
- Custom Vector implementation

### Algorithms
- **Searching:** Linear, Binary Search
- **Sorting:** Heap Sort, Merge Sort
- **Graph Algorithms:** BFS, DFS
- **Greedy Algorithms:** Scheduling, Optimization
- **Dynamic Programming:** Knapsack problem
- **Divide and Conquer:** Recursive problem solving

### Software Engineering Practices
- **Memory Management:** Manual memory allocation/deallocation
- **File I/O:** Input/output operations with error handling
- **Template Programming:** Generic data structure implementations
- **Algorithm Analysis:** Time and space complexity understanding
- **Problem Solving:** Systematic approach to complex problems

## üìä Complexity Analysis
- **Time Complexity:** Implemented algorithms with optimal time complexity
- **Space Complexity:** Efficient memory usage and management
- **Big O Notation:** Understanding and application of complexity analysis


## üöÄ Career Relevance
This coursework demonstrates:
- **Problem-solving abilities** essential for technical interviews
- **Algorithm design skills** required for software engineering roles
- **Data structure knowledge** fundamental to system design
- **C++ programming expertise** valuable for systems programming
- **Analytical thinking** crucial for software development

## üìÅ Repository Structure
```
Data-Structure-and-Algorithm-1/
‚îú‚îÄ‚îÄ 1.Array&LinkedList/     # List implementations and LRU cache
‚îú‚îÄ‚îÄ 2.Stack&Queue/          # Stack and queue data structures
‚îú‚îÄ‚îÄ 3.BinarySearchTree/     # BST implementation and operations
‚îú‚îÄ‚îÄ 4.Heap/                 # Min heap and priority queue
‚îú‚îÄ‚îÄ 5.Graph/                # Graph algorithms (BFS, DFS)
‚îú‚îÄ‚îÄ 6.GreedyAlgorithm/      # Greedy scheduling algorithms
‚îú‚îÄ‚îÄ 7.DivideAndConquer/     # Divide and conquer problems
‚îú‚îÄ‚îÄ 8.DynamicProgramming/   # DP solutions (Knapsack)
‚îî‚îÄ‚îÄ README.md              # This file
```

## üîß How to Use
Each module contains:
- **Source Code:** Complete C++ implementations
- **Specifications:** Problem descriptions and requirements
- **Test Cases:** Input/output examples
- **Documentation:** Implementation details and complexity analysis

## üìà Learning Outcomes
- Mastered fundamental data structures and algorithms
- Developed strong problem-solving and analytical skills
- Gained practical experience with C++ programming
- Understood algorithm design and optimization techniques
- Prepared for advanced computer science courses and technical interviews

---

*This portfolio represents a comprehensive foundation in data structures and algorithms, demonstrating both theoretical understanding and practical implementation skills essential for software development careers.*
